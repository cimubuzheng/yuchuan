//+------------------------------------------------------------------+
//|                                      宇川策略AI智能交易系统6.1.mq5 |
//|                        Copyright 2025, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "宇川策略AI量化工作室"
#property link      "微信 cimubuzheng"
#property version   "6.1"
#property strict

//--- 包含文件
#include <Trade\Trade.mqh>
#include <Math\Stat\Normal.mqh>

//--- 全局交易对象
CTrade trade;

//--- 输入参数
input string   AuthorizedAccounts = "7277935,277227475"; // 授权账号
input datetime AuthorizationExpiry = D'2025.12.31 23:59:59'; // 授权到期时间
input bool     EnableAIAnalysis = true;                // 启用AI分析
input int      AnalysisIntervalSeconds = 600;          // 分析间隔(秒)
input double   SingleRiskPercent = 1.0;                // 单笔风险(%)
input double   DailyRiskLimit = 3.0;                   // 单日风险(%)
input double   MinRiskRewardRatio = 2.0;               // 最小风险回报比
input int      MaxDailyTrades = 3;                     // 最大每日交易数
input string   TradingSymbols = "EURUSD,XAUUSD,GBPUSD"; // 交易品种

//--- AI全自动交易参数
input bool     EnableAIFullAuto = false;              // 启用AI全自动交易
input string   AITradingPrompt = "你是一个拥有20年交易经验的专业交易员..."; // AI交易提示词
input int      AIDecisionInterval = 300;              // AI决策间隔(秒)
input double   AITradingConfidence = 0.75;             // AI交易置信度阈值
input bool     AILimitByRiskParams = true;             // AI受风险参数限制
input bool     AIShowDecisionProcess = true;           // 显示AI决策过程

//--- DeepSeek API配置
input string   DeepSeekAPIKey = "sk-12a1ae199f05481a85c899561e669a1a"; // DeepSeek API密钥
input string   DeepSeekBaseURL = "https://api.deepseek.com/v1/chat/completions"; // DeepSeek API地址
input int      APITimeout = 30000;                     // API请求超时(毫秒)
input bool     EnableAPILog = true;                    // 启用API日志

//--- 策略参数
input bool     EnableTrendFollowing = true;            // 启用趋势跟踪策略
input bool     EnableMeanReversion = true;             // 启用均值回归策略
input bool     EnableTurtleTrading = true;             // 启用海龟交易策略
input bool     EnableRule123 = true;                   // 启用123法则策略
input bool     EnablePriceAction = true;               // 启用裸K策略
input bool     EnableVolatilityBreakout = true;        // 启用波动率突破策略
input bool     EnableBollingerReversion = true;        // 启用布林带回归策略
input bool     EnableSMC = true;                       // 启用SMC聪明钱概念
input bool     EnableGoldenCross = true;               // 启用金叉死叉策略

//--- 时间框架配置
input ENUM_TIMEFRAMES  MainTF = PERIOD_M15;            // 主交易时间框架
input ENUM_TIMEFRAMES  ConfirmTF = PERIOD_H1;          // 确认时间框架
input ENUM_TIMEFRAMES  TrendTF = PERIOD_H4;            // 趋势判断时间框架

//--- 布林带参数
input int      BollingerPeriod = 20;                   // 布林带周期
input double   StdDevMultiplier = 2.0;                 // 标准差倍数
input double   OverboughtThreshold = 70;               // 超买阈值(结合RSI)
input double   OversoldThreshold = 30;                 // 超卖阈值(结合RSI)
input bool     UseRSIFilter = true;                    // 使用RSI过滤信号

//--- 金叉死叉参数
input int      FastMAPeriod = 50;                      // 快线周期
input int      SlowMAPeriod = 200;                     // 慢线周期
input ENUM_MA_METHOD MAMethod = MODE_SMA;              // MA计算方法
input int      SignalConfirmBars = 2;                  // 信号确认柱数

//--- 策略权重
input double   TrendFollowingWeight = 0.15;            // 趋势跟踪权重
input double   MeanReversionWeight = 0.12;             // 均值回归权重
input double   TurtleTradingWeight = 0.15;             // 海龟交易权重
input double   Rule123Weight = 0.12;                   // 123法则权重
input double   PriceActionWeight = 0.12;                // 裸K策略权重
input double   VolatilityBreakoutWeight = 0.12;         // 波动率突破权重
input double   BollingerReversionWeight = 0.11;         // 布林带回归权重
input double   SMCWeight = 0.11;                       // SMC聪明钱概念权重
input double   GoldenCrossWeight = 0.11;               // 金叉死叉权重

//--- 止盈止损参数
input bool     EnableAdaptiveSLTP = true;              // 启用自适应止盈止损
input double   M15ATRSLMultiplier = 1.5;               // M15周期ATR止损乘数
input double   M15ATRTPMultiplier = 3.0;               // M15周期ATR止盈乘数
input double   H1ATRSLMultiplier = 2.0;                // H1周期ATR止损乘数
input double   H1ATRTPMultiplier = 4.0;                // H1周期ATR止盈乘数

//--- AI智能分析参数
input double   AIConfidenceThreshold = 0.65;           // AI置信度阈值
input bool     EnableDetailedLog = true;               // 启用详细日志
input int      AIMaxTokens = 1000;                     // AI最大返回token数
input double   AICreativityParam = 0.7;                // AI创造性参数(0-1)

//--- 动态风险参数
input int      MaxConsecutiveLosses = 3;               // 最大连续亏损次数
input double   MaxDailyDrawdownPercent = 15.0;         // 最大日回撤百分比

//--- 市场状态识别参数
input int      StateUpdateInterval = 3600;             // 状态更新间隔(秒)
input double   TrendADXThreshold = 25.0;               // ADX>25判断为趋势市
input double   RangeADXThreshold = 20.0;               // ADX<20判断为震荡市
input double   BreakoutVolatilityThreshold = 1.8;       // 波动率比率>1.8判断突破
input bool     EnableEnhancedState = true;             // 启用增强识别功能

//--- 复盘配置
input bool     EnableDailyReview = true;               // 启用每日自动复盘
input bool     EnableWeeklyReview = true;              // 启用每周自动复盘
input bool     EnableMonthlyReview = true;              // 启用每月自动复盘
input int      DailyReviewHour = 23;                   // 每日复盘时间(小时,0-23)
input int      WeeklyReviewDay = 6;                    // 每周复盘日(0-6,0=周日)
input int      MonthlyReviewDay = 28;                  // 每月复盘日(1-28)
input bool     GenerateDetailedReport = true;          // 生成详细文本报告
input string   ReportSavePath = "Reports/";            // 报告保存路径

//--- 新增参数
input bool     EnableML = false;                       // 启用机器学习
input double   MLWeight = 0.1;                         // 机器学习权重
input bool     MartingaleEnabled = false;              // 启用马丁策略
input bool     GridEnabled = false;                    // 启用网格策略
input double   AIConfidence = 0.7;                     // AI置信度
input bool     EnableCustomPrompt = true;              // 启用自定义提示词

//--- 市场状态枚举
enum ENUM_MARKET_STATE {
   MARKET_TREND,     // 趋势市
   MARKET_RANGE,     // 震荡市
   MARKET_BREAKOUT   // 突破市
};

//--- 策略信号结构
struct StrategySignal {
   string      StrategyName;          // 策略名称
   string      SignalDirection;       // 信号方向(BUY/SELL/HOLD)
   int         SignalStrength;        // 信号强度(0-100)
   double      Confidence;            // 置信度(0-1)
   string      DecisionReason;        // 决策理由
   double      EstimatedWinRate;     // 预估胜率
   datetime    SignalExpiry;          // 信号有效期
   string      SMCKeyLevel;          // SMC关键水平
   double      LiquidityScore;        // 流动性评分
   double      MLScore;               // 机器学习评分
};

//--- 交易信号结构
struct TradeSignal {
   string      Direction;
   int         Strength;
   double      Confidence;
   string      Reason;
   StrategySignal StrategyArray[10];  // 固定大小数组
   int         ValidStrategyCount;    // 有效策略数量
};

//--- 交易记录结构
struct TradeRecord {
   datetime    Time;
   string      Symbol;
   string      Direction;
   double      Volume;
   double      Profit;
   string      Strategy;
   string      Comment;
   double      SL;
   double      TP;
   int         HoldTime; // 分钟
};

//--- 复盘统计结构
struct ReviewStatistics {
   int         TotalTrades;
   int         WinTrades;
   int         LossTrades;
   double      TotalProfit;
   double      AvgProfit;
   double      WinRate;
   double      ProfitFactor;
   int         MaxWinStreak;
   int         MaxLossStreak;
   double      MaxDrawdown;
   datetime    StartTime;
   datetime    EndTime;
};

//--- AI决策结构
struct AITradingDecision {
   string      action;
   string      symbol;
   string      direction;
   double      volume;
   double      stopLoss;
   double      takeProfit;
   double      confidence;
   string      reasoning;
   datetime    expiry;
   bool        closeAll;
   string      closeSymbol;
   int         closePositionType;
};

//--- 网格状态结构
struct GridStatus {
   double      basePrice;
   int         currentBuyLevel;
   int         currentSellLevel;
};

//--- API响应结构
struct DeepSeekResponse {
   string      id;
   string      object;
   int         created;
   string      model;
   string      content;
   string      finish_reason;
   int         usage_total_tokens;
   bool        success;
   string      error_message;
};

//--- 全局变量
string   SymbolArray[];
int      maHandle_TF1[];
int      maHandle_TF2[];
int      maHandle_TF3[];
int      rsiHandle_TF1[];
int      rsiHandle_TF2[];
int      atrHandle[];
int      macdHandle[];
int      bbandsHandle[];
int      gcFastMAHandle[];
int      gcSlowMAHandle[];
int      adxHandle[];

TradeRecord TradeHistory[1000];
int      TradeRecordCount = 0;
ReviewStatistics CurrentStats;
GridStatus gridStatus[];

//--- 马丁策略参数
input double   MartingaleStartLot = 0.01;              // 马丁起始手数
input double   MartingaleMultiplier = 2.0;             // 马丁乘数
input int      MartingaleMaxLevels = 5;                // 马丁最大层数
input double   MartingaleTPRatio = 3.0;                // 马丁止盈比率
input int      MartingaleSLPoints = 500;               // 马丁止损点数
input bool     MartingaleTrendFilter = true;          // 马丁趋势过滤

//--- 网格策略参数
input double   GridStartLot = 0.01;                   // 网格起始手数
input int      GridSpacingPoints = 50;                // 网格间距点数
input int      GridLevels = 10;                       // 网格层数
input int      GridTPPoints = 100;                    // 网格止盈点数
input bool     GridTrendFilter = true;                // 网格趋势过滤

//--- 系统状态变量
datetime StartTime;
datetime LastAnalysisTime = 0;
int      DailyTradeCount = 0;
double   DailyLoss = 0.0;
int      ConsecutiveLosses = 0;
datetime RestStartTime = 0;
bool     SystemError = false;
string   ErrorReason = "";
datetime LastMLPredictionTime = 0;
double   MLPredictionValue = 0;
double   MLConfidence = 0.0;
ENUM_MARKET_STATE currentMarketState = MARKET_RANGE;
datetime lastStateUpdate = 0;
datetime LastDailyReviewTime = 0;
datetime LastWeeklyReviewTime = 0;
datetime LastMonthlyReviewTime = 0;
bool     AIProcessing = false;
datetime LastAIDecisionTime = 0;

//--- 策略启用状态
bool TrendFollowingEnabled = true;
bool MeanReversionEnabled = true;
bool TurtleTradingEnabled = true;
bool Rule123Enabled = true;
bool PriceActionEnabled = true;
bool VolatilityBreakoutEnabled = true;
bool BollingerReversionEnabled = true;
bool SMCEnabled = true;
bool GoldenCrossEnabled = true;

//+------------------------------------------------------------------+
//| 初始化函数                                                       |
//+------------------------------------------------------------------+
int OnInit()
{
   StartTime = TimeCurrent();
   
   // 授权检查
   if(!CheckAuthorization()) {
      SystemError = true;
      ErrorReason = "授权验证失败";
      return INIT_FAILED;
   }

   // 初始化交易品种
   int symbolCount = StringSplit(TradingSymbols, ',', SymbolArray);
   if(symbolCount <= 0) {
      Print("错误: 无效的交易品种");
      return INIT_FAILED;
   }

   // 初始化指标句柄数组
   ArrayResize(maHandle_TF1, symbolCount);
   ArrayResize(maHandle_TF2, symbolCount);
   ArrayResize(maHandle_TF3, symbolCount);
   ArrayResize(rsiHandle_TF1, symbolCount);
   ArrayResize(rsiHandle_TF2, symbolCount);
   ArrayResize(atrHandle, symbolCount);
   ArrayResize(macdHandle, symbolCount);
   ArrayResize(bbandsHandle, symbolCount);
   ArrayResize(gcFastMAHandle, symbolCount);
   ArrayResize(gcSlowMAHandle, symbolCount);
   ArrayResize(adxHandle, symbolCount);

   // 初始化网格状态
   ArrayResize(gridStatus, symbolCount);

   // 为每个品种初始化指标
   for(int i = 0; i < symbolCount; i++) {
      string symbol = SymbolArray[i];
      
      maHandle_TF1[i] = iMA(symbol, MainTF, 50, 0, MODE_SMA, PRICE_CLOSE);
      maHandle_TF2[i] = iMA(symbol, ConfirmTF, 100, 0, MODE_SMA, PRICE_CLOSE);
      maHandle_TF3[i] = iMA(symbol, TrendTF, 200, 0, MODE_SMA, PRICE_CLOSE);
      rsiHandle_TF1[i] = iRSI(symbol, MainTF, 14, PRICE_CLOSE);
      rsiHandle_TF2[i] = iRSI(symbol, ConfirmTF, 14, PRICE_CLOSE);
      atrHandle[i] = iATR(symbol, MainTF, 14);
      macdHandle[i] = iMACD(symbol, MainTF, 12, 26, 9, PRICE_CLOSE);
      bbandsHandle[i] = iBands(symbol, MainTF, BollingerPeriod, 0, StdDevMultiplier, PRICE_CLOSE);
      gcFastMAHandle[i] = iMA(symbol, MainTF, FastMAPeriod, 0, MAMethod, PRICE_CLOSE);
      gcSlowMAHandle[i] = iMA(symbol, MainTF, SlowMAPeriod, 0, MAMethod, PRICE_CLOSE);
      adxHandle[i] = iADX(symbol, MainTF, 14);

      // 初始化网格状态
      gridStatus[i].basePrice = 0;
      gridStatus[i].currentBuyLevel = 0;
      gridStatus[i].currentSellLevel = 0;
      
      // 验证指标句柄
      if(maHandle_TF1[i] == INVALID_HANDLE || rsiHandle_TF1[i] == INVALID_HANDLE || atrHandle[i] == INVALID_HANDLE) {
         Print("错误: 指标初始化失败 - ", symbol);
         return INIT_FAILED;
      }
   }

   Print("=== 宇川AI智能交易系统V6.1初始化成功 ===");
   Print("交易品种: ", TradingSymbols);
   Print("主时间框架: ", EnumToString(MainTF));
   Print("AI分析: ", EnableAIAnalysis ? "启用" : "禁用");
   Print("授权账号: ", AuthorizedAccounts);
   Print("授权到期: ", TimeToString(AuthorizationExpiry));
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| 授权校验函数                                                     |
//+------------------------------------------------------------------+
bool CheckAuthorization()
{
   long currentAccount = AccountInfoInteger(ACCOUNT_LOGIN);
   string accountList[];
   int count = StringSplit(AuthorizedAccounts, ',', accountList);
   bool accountAuthorized = false;

   for(int i = 0; i < count; i++) {
      if(StringToInteger(accountList[i]) == currentAccount) {
         accountAuthorized = true;
         break;
      }
   }

   if(!accountAuthorized) {
      Print("账号 " + IntegerToString(currentAccount) + " 未授权");
      return false;
   }

   datetime currentTime = TimeCurrent();
   if(currentTime > AuthorizationExpiry) {
      Print("EA使用已过期，当前时间: " + TimeToString(currentTime) +
            " 有效期至: " + TimeToString(AuthorizationExpiry));
      return false;
   }

   return true;
}

//+------------------------------------------------------------------+
//| 逆初始化函数                                                     |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // 释放所有指标句柄
   for(int i = 0; i < ArraySize(SymbolArray); i++) {
      if(maHandle_TF1[i] != INVALID_HANDLE) IndicatorRelease(maHandle_TF1[i]);
      if(maHandle_TF2[i] != INVALID_HANDLE) IndicatorRelease(maHandle_TF2[i]);
      if(maHandle_TF3[i] != INVALID_HANDLE) IndicatorRelease(maHandle_TF3[i]);
      if(rsiHandle_TF1[i] != INVALID_HANDLE) IndicatorRelease(rsiHandle_TF1[i]);
      if(rsiHandle_TF2[i] != INVALID_HANDLE) IndicatorRelease(rsiHandle_TF2[i]);
      if(atrHandle[i] != INVALID_HANDLE) IndicatorRelease(atrHandle[i]);
      if(macdHandle[i] != INVALID_HANDLE) IndicatorRelease(macdHandle[i]);
      if(bbandsHandle[i] != INVALID_HANDLE) IndicatorRelease(bbandsHandle[i]);
      if(gcFastMAHandle[i] != INVALID_HANDLE) IndicatorRelease(gcFastMAHandle[i]);
      if(gcSlowMAHandle[i] != INVALID_HANDLE) IndicatorRelease(gcSlowMAHandle[i]);
      if(adxHandle[i] != INVALID_HANDLE) IndicatorRelease(adxHandle[i]);
   }
   
   // 保存交易历史
   SaveTradeHistory();
   
   // 生成最终报告
   GenerateFinalReport(reason);
   
   Print("=== 宇川AI智能交易系统V6.1停止运行 ===");
   Print("运行时长: ", DoubleToString((TimeCurrent() - StartTime) / 3600.0, 1), " 小时");
   Print("总交易次数: ", TradeRecordCount);
}

//+------------------------------------------------------------------+
//| Tick处理函数                                                     |
//+------------------------------------------------------------------+
void OnTick()
{
   // 检查系统状态
   if(SystemError || !CanTrade()) return;
   
   datetime currentTime = TimeCurrent();
   
   // AI全自动策略优先执行
   if(EnableAIFullAuto) {
      ExecuteAIFullAutoTrading();
      return;
   }
   
   // 检查是否在休息期
   if(IsResting()) return;
   
   // 定期更新市场状态
   if(EnableEnhancedState && currentTime - lastStateUpdate >= StateUpdateInterval) {
      for(int i = 0; i < ArraySize(SymbolArray); i++) {
         currentMarketState = AnalyzeMarketState(SymbolArray[i], i);
         lastStateUpdate = currentTime;
         AdjustStrategyConfig(currentMarketState);
      }
   }
   
   // 定期分析
   if(currentTime - LastAnalysisTime >= AnalysisIntervalSeconds) {
      if(EnableDetailedLog) Print("=== 开始多品种多策略分析 ===");

      for(int i = 0; i < ArraySize(SymbolArray); i++) {
         string symbol = SymbolArray[i];
         
         if(HasPosition(symbol)) continue;
         if(!CheckTradeConditions(symbol)) continue;

         TradeSignal signal;
         if(MultiStrategyAnalysis(symbol, i, signal)) {
            RecordAIAnalysis(symbol, signal);

            if(signal.Direction != "HOLD" && signal.Confidence > AIConfidenceThreshold) {
               double lotSize, stopLoss, takeProfit;
               if(CalculateRisk(symbol, signal, lotSize, stopLoss, takeProfit, i)) {
                  string comment = "宇川AI-" + signal.StrategyArray[0].StrategyName + "+" + 
                                 IntegerToString(signal.StrategyArray[0].SignalStrength);

                  if(ExecuteTrade(symbol, signal.Direction, lotSize, stopLoss, takeProfit, comment)) {
                     DailyTradeCount++;
                     RecordTrade(symbol, signal.Direction, lotSize, 0, 
                               signal.StrategyArray[0].StrategyName, comment, stopLoss, takeProfit, 0);
                  }
               }
            }
         }
      }
      LastAnalysisTime = currentTime;
   }
   
   // 检查复盘时机
   CheckReviewTiming();
   
   // 风险检查
   CheckRiskManagement();
}

//+------------------------------------------------------------------+
//| AI全自动交易执行函数                                             |
//+------------------------------------------------------------------+
void ExecuteAIFullAutoTrading()
{
   if(!EnableAIFullAuto || AIProcessing) return;
   
   datetime currentTime = TimeCurrent();
   if(currentTime - LastAIDecisionTime < AIDecisionInterval) return;
   
   AIProcessing = true;
   
   if(AIShowDecisionProcess) {
      Print("=== 开始AI全自动交易分析 ===");
   }
   
   // 准备AI分析数据
   string marketData = PrepareAIMarketData();
   string accountData = PrepareAIAccountData();
   string positionData = PrepareAIPositionData();
   
   // 构建完整的AI提示词
   string fullPrompt = BuildAITradingPrompt(marketData, accountData, positionData);
   
   if(AIShowDecisionProcess) {
      Print("AI提示词: ", fullPrompt);
   }
   
   // 调用AI决策
   AITradingDecision decision;
   if(GetAITradingDecision(fullPrompt, decision)) {
      if(decision.confidence >= AITradingConfidence) {
         ExecuteAIDecision(decision);
      } else {
         Print("AI决策置信度不足: ", DoubleToString(decision.confidence, 2));
      }
   }
   
   LastAIDecisionTime = currentTime;
   AIProcessing = false;
}

//+------------------------------------------------------------------+
//| 多策略分析引擎                                                   |
//+------------------------------------------------------------------+
bool MultiStrategyAnalysis(string symbol, int symbolIndex, TradeSignal &signal)
{
   signal.Direction = "HOLD";
   signal.Strength = 0;
   signal.Confidence = 0.5;
   signal.Reason = "";
   signal.ValidStrategyCount = 0;

   // 重置策略数组
   ArrayInitialize(signal.StrategyArray, 0);

   StrategySignal strategies[10];
   int validCount = 0;

   // 收集所有策略信号
   if(TrendFollowingEnabled && validCount < 10) {
      if(TrendFollowingStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(MeanReversionEnabled && validCount < 10) {
      if(MeanReversionStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(TurtleTradingEnabled && validCount < 10) {
      if(TurtleTradingStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(Rule123Enabled && validCount < 10) {
      if(Rule123Strategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(PriceActionEnabled && validCount < 10) {
      if(PriceActionStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(VolatilityBreakoutEnabled && validCount < 10) {
      if(VolatilityBreakoutStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(BollingerReversionEnabled && validCount < 10) {
      if(BollingerStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(SMCEnabled && validCount < 10) {
      if(SMCStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }
   
   if(GoldenCrossEnabled && validCount < 10) {
      if(GoldenCrossStrategy(symbol, symbolIndex, strategies[validCount])) {
         validCount++;
      }
   }

//+------------------------------------------------------------------+
//| 机器学习策略实现                                                 |
//+------------------------------------------------------------------+
bool MachineLearningStrategy(string symbol, int symbolIndex, StrategySignal &signal)
{
   signal.StrategyName = "MachineLearning";
   signal.SignalDirection = "HOLD";

   // 获取机器学习预测
   double prediction, confidence;
   if(GetMLPrediction(symbol, prediction, confidence)) {
      if(prediction > 0.6) {
         signal.SignalDirection = "BUY";
         signal.SignalStrength = (int)(confidence * 100);
         signal.Confidence = confidence;
         signal.DecisionReason = "LSTM神经网络预测看涨";
         signal.EstimatedWinRate = 72;
         signal.MLScore = prediction;
      } else if(prediction < -0.6) {
         signal.SignalDirection = "SELL";
         signal.SignalStrength = (int)(confidence * 100);
         signal.Confidence = confidence;
         signal.DecisionReason = "LSTM神经网络预测看跌";
         signal.EstimatedWinRate = 72;
         signal.MLScore = prediction;
      }
   }

   signal.SignalExpiry = TimeCurrent() + 1800; // 30分钟有效期
   return (signal.SignalDirection != "HOLD");
}

//+------------------------------------------------------------------+
//| 获取机器学习预测函数                                             |
//+------------------------------------------------------------------+
bool GetMLPrediction(string symbol, double &Prediction, double &Confidence)
{
   if(!EnableML) return false;
   
   datetime CurrentTime = TimeCurrent();
   if(CurrentTime - LastMLPredictionTime < 3600) {
      Prediction = MLPredictionValue;
      Confidence = MLConfidence;
      return true;
   }
   
   // 准备特征数据
   double features[];
   if(!PrepareMLFeatures(symbol, features)) {
      return false;
   }
   
   // 简化的机器学习预测实现
   // 实际中需要调用机器学习服务API
   Prediction = 0.0;
   Confidence = 0.5;
   
   // 基于技术指标的简单预测
   int symbolIndex = GetSymbolIndex(symbol);
   if(symbolIndex >= 0) {
      double rsi = GetIndicatorValue(rsiHandle_TF1[symbolIndex]);
      double maFast = GetIndicatorValue(maHandle_TF1[symbolIndex]);
      double maSlow = GetIndicatorValue(maHandle_TF2[symbolIndex]);
      double atr = GetIndicatorValue(atrHandle[symbolIndex]);
      double adx = GetIndicatorValue(adxHandle[symbolIndex]);
      
      // 多因子模型
      double score = 0;
      
      // RSI因子
      if(rsi < 30) score += 0.3;
      else if(rsi > 70) score -= 0.3;
      
      // 均线因子
      if(maFast > maSlow) score += 0.2;
      else score -= 0.2;
      
      // 波动率因子
      double volatilityRatio = atr / SymbolInfoDouble(symbol, SYMBOL_BID);
      if(volatilityRatio > 0.0015) score += 0.1;
      
      // 趋势强度因子
      if(adx > 25) score += 0.2;
      
      // 价格动量因子
      double priceChange[5];
      if(CopyClose(symbol, MainTF, 0, 5, priceChange) > 0) {
         double momentum = (priceChange[0] - priceChange[4]) / priceChange[4];
         if(momentum > 0.002) score += 0.2;
         else if(momentum < -0.002) score -= 0.2;
      }
      
      Prediction = score;
      Confidence = 0.6 + MathAbs(score) * 0.4;
      
      if(score > 0.5) {
         Prediction = 1.0;
      } else if(score < -0.5) {
         Prediction = -1.0;
      }
   }
   
   MLPredictionValue = Prediction;
   MLConfidence = Confidence;
   LastMLPredictionTime = CurrentTime;
   
   return (Prediction != 0.0);
}

//+------------------------------------------------------------------+
//| 准备机器学习特征函数                                             |
//+------------------------------------------------------------------+
bool PrepareMLFeatures(string symbol, double &features[])
{
   int symbolIndex = GetSymbolIndex(symbol);
   if(symbolIndex < 0) return false;
   
   // 获取技术指标值
   double rsi = GetIndicatorValue(rsiHandle_TF1[symbolIndex]);
   double maFast = GetIndicatorValue(maHandle_TF1[symbolIndex]);
   double maSlow = GetIndicatorValue(maHandle_TF2[symbolIndex]);
   double atr = GetIndicatorValue(atrHandle[symbolIndex]);
   double adx = GetIndicatorValue(adxHandle[symbolIndex]);
   
   // 获取价格数据
   double close[10], high[10], low[10];
   if(CopyClose(symbol, MainTF, 0, 10, close) <= 0) return false;
   if(CopyHigh(symbol, MainTF, 0, 10, high) <= 0) return false;
   if(CopyLow(symbol, MainTF, 0, 10, low) <= 0) return false;
   
   // 计算特征
   ArrayResize(features, 15);
   
   // 1. RSI值
   features[0] = rsi;
   
   // 2. 均线差值比率
   features[1] = (maFast - maSlow) / SymbolInfoDouble(symbol, SYMBOL_BID);
   
   // 3. ATR波动率
   features[2] = atr / SymbolInfoDouble(symbol, SYMBOL_BID);
   
   // 4. ADX趋势强度
   features[3] = adx;
   
   // 5. 价格动量 (5周期)
   features[4] = (close[0] - close[4]) / close[4];
   
   // 6. 价格动量 (10周期)
   features[5] = (close[0] - close[9]) / close[9];
   
   // 7. 最高价突破
   features[6] = (close[0] - high[ArrayMaximum(high, 1, 9)]) / high[ArrayMaximum(high, 1, 9)];
   
   // 8. 最低价突破
   features[7] = (close[0] - low[ArrayMinimum(low, 1, 9)]) / low[ArrayMinimum(low, 1, 9)];
   
   // 9. 价格波动范围
   features[8] = (high[ArrayMaximum(high, 0, 9)] - low[ArrayMinimum(low, 0, 9)]) / close[0];
   
   // 10. 成交量变化 (如果有)
   if(SymbolInfoInteger(symbol, SYMBOL_TRADE_CALC_MODE) != SYMBOL_CALC_MODE_FOREX) {
      long volume[5];
      if(CopyTickVolume(symbol, MainTF, 0, 5, volume) > 0) {
         features[9] = (double)(volume[0] - volume[4]) / volume[4];
      }
   }
   
   // 11. RSI动量
   double rsiValues[5];
   if(CopyBuffer(rsiHandle_TF1[symbolIndex], 0, 0, 5, rsiValues) > 0) {
      features[10] = rsiValues[0] - rsiValues[4];
   }
   
   // 12. 布林带位置
   double upperBand[1], lowerBand[1];
   if(CopyBuffer(bbandsHandle[symbolIndex], 0, 0, 1, upperBand) > 0 &&
      CopyBuffer(bbandsHandle[symbolIndex], 2, 0, 1, lowerBand) > 0) {
      features[11] = (close[0] - lowerBand[0]) / (upperBand[0] - lowerBand[0]);
   }
   
   // 13. MACD信号
   double macdMain[1], macdSignal[1];
   if(CopyBuffer(macdHandle[symbolIndex], 0, 0, 1, macdMain) > 0 &&
      CopyBuffer(macdHandle[symbolIndex], 1, 0, 1, macdSignal) > 0) {
      features[12] = macdMain[0] - macdSignal[0];
   }
   
   // 14. 价格加速度
   features[13] = ((close[0] - close[2]) / 2 - (close[2] - close[4]) / 2) / close[0];
   
   // 15. 市场状态特征
   features[14] = (double)currentMarketState;
   
   return true;
}

//+------------------------------------------------------------------+
//| 获取品种索引函数                                                 |
//+------------------------------------------------------------------+
int GetSymbolIndex(string symbol)
{
   for(int i = 0; i < ArraySize(SymbolArray); i++) {
      if(SymbolArray[i] == symbol) return i;
   }
   return -1;
}

//+------------------------------------------------------------------+
//| 获取指标值函数                                                   |
//+------------------------------------------------------------------+
double GetIndicatorValue(int handle)
{
   double value[1];
   if(CopyBuffer(handle, 0, 0, 1, value) <= 0) return 0;
   return value[0];
}

//+------------------------------------------------------------------+
//| 准备AI市场数据函数                                               |
//+------------------------------------------------------------------+
string PrepareAIMarketData()
{
   string data = "当前市场状态分析:\n";
   
   for(int i = 0; i < ArraySize(SymbolArray); i++) {
      string symbol = SymbolArray[i];
      
      data += "品种: " + symbol + "\n";
      data += "价格: " + DoubleToString(SymbolInfoDouble(symbol, SYMBOL_BID), 5) + "\n";
      data += "点差: " + DoubleToString(SymbolInfoDouble(symbol, SYMBOL_ASK) - SymbolInfoDouble(symbol, SYMBOL_BID), 1) + " pips\n";
      
      // 技术指标数据
      data += "RSI(14): " + DoubleToString(GetIndicatorValue(rsiHandle_TF1[i]), 1) + "\n";
      data += "ATR(14): " + DoubleToString(GetIndicatorValue(atrHandle[i]), 5) + "\n";
      data += "快慢均线差: " + DoubleToString(GetIndicatorValue(maHandle_TF1[i]) - GetIndicatorValue(maHandle_TF2[i]), 5) + "\n";
      data += "ADX: " + DoubleToString(GetIndicatorValue(adxHandle[i]), 1) + "\n";
      
      // 市场状态
      data += "市场状态: ";
      switch(currentMarketState) {
         case MARKET_TREND: data += "趋势市"; break;
         case MARKET_RANGE: data += "震荡市"; break;
         case MARKET_BREAKOUT: data += "突破市"; break;
      }
      data += "\n\n";
   }
   
   return data;
}

//+------------------------------------------------------------------+
//| 准备AI账户数据函数                                               |
//+------------------------------------------------------------------+
string PrepareAIAccountData()
{
   string data = "账户状态分析:\n";
   data += "余额: " + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2) + " USD\n";
   data += "净值: " + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2) + " USD\n";
   data += "可用保证金: " + DoubleToString(AccountInfoDouble(ACCOUNT_MARGIN_FREE), 2) + " USD\n";
   data += "保证金比率: " + DoubleToString(AccountInfoDouble(ACCOUNT_MARGIN_LEVEL), 2) + "%\n";
   data += "当日盈亏: " + DoubleToString(AccountInfoDouble(ACCOUNT_PROFIT), 2) + " USD\n";
   data += "持仓数量: " + IntegerToString(PositionsTotal()) + "\n";
   data += "当日交易次数: " + IntegerToString(DailyTradeCount) + "/" + IntegerToString(MaxDailyTrades) + "\n";
   data += "连续亏损: " + IntegerToString(ConsecutiveLosses) + "/" + IntegerToString(MaxConsecutiveLosses) + "\n\n";
   
   return data;
}

//+------------------------------------------------------------------+
//| 准备AI持仓数据函数                                               |
//+------------------------------------------------------------------+
string PrepareAIPositionData()
{
   string data = "当前持仓分析:\n";
   
   if(PositionsTotal() == 0) {
      data += "无持仓\n\n";
      return data;
   }
   
   for(int i = 0; i < PositionsTotal(); i++) {
      if(PositionGetTicket(i)) {
         string symbol = PositionGetString(POSITION_SYMBOL);
         long type = PositionGetInteger(POSITION_TYPE);
         double volume = PositionGetDouble(POSITION_VOLUME);
         double profit = PositionGetDouble(POSITION_PROFIT);
         double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
         string comment = PositionGetString(POSITION_COMMENT);
         
         data += symbol + " " + (type == POSITION_TYPE_BUY ? "买入" : "卖出") + 
                " 手数:" + DoubleToString(volume, 2) + 
                " 盈亏:" + DoubleToString(profit, 2) + 
                " 开仓价:" + DoubleToString(openPrice, 5) + 
                " 注释:" + comment + "\n";
      }
   }
   data += "\n";
   
   return data;
}

//+------------------------------------------------------------------+
//| 构建AI交易提示词函数                                             |
//+------------------------------------------------------------------+
string BuildAITradingPrompt(string marketData, string accountData, string positionData)
{
   string prompt = AITradingPrompt + "\n\n";
   
   prompt += "=== 市场数据 ===\n";
   prompt += marketData + "\n";
   
   prompt += "=== 账户状态 ===\n";
   prompt += accountData + "\n";
   
   prompt += "=== 持仓情况 ===\n";
   prompt += positionData + "\n";
   
   prompt += "=== 交易指令 ===\n";
   prompt += "请基于以上分析给出交易建议，包括:\n";
   prompt += "1. 操作类型(开仓/平仓/观望)\n";
   prompt += "2. 交易品种\n";
   prompt += "3. 交易方向(买入/卖出)\n";
   prompt += "4. 手数大小\n";
   prompt += "5. 止损位置\n";
   prompt += "6. 止盈位置\n";
   prompt += "7. 置信度(0-1)\n";
   prompt += "8. 决策理由\n\n";
   
   prompt += "请用JSON格式返回分析结果。\n";
   
   return prompt;
}

//+------------------------------------------------------------------+
//| 获取AI交易决策函数                                               |
//+------------------------------------------------------------------+
bool GetAITradingDecision(string prompt, AITradingDecision &decision)
{
   if(!EnableAIAnalysis || StringLen(DeepSeekAPIKey) < 10) {
      // 模拟AI决策
      decision.action = "HOLD";
      decision.confidence = 0.5;
      decision.reasoning = "AI分析未启用";
      return true;
   }
   
   // 构建请求数据
   string headers = "Content-Type: application/json\r\n";
   headers += "Authorization: Bearer " + DeepSeekAPIKey + "\r\n";
   
   string request_data = "{\n";
   request_data += "  \"model\": \"deepseek-chat\",\n";
   request_data += "  \"messages\": [\n";
   request_data += "    {\n";
   request_data += "      \"role\": \"user\",\n";
   request_data += "      \"content\": \"" + EscapeJSONString(prompt) + "\"\n";
   request_data += "    }\n";
   request_data += "  ],\n";
   request_data += "  \"temperature\": " + DoubleToString(AICreativityParam, 1) + ",\n";
   request_data += "  \"max_tokens\": " + IntegerToString(AIMaxTokens) + ",\n";
   request_data += "  \"stream\": false\n";
   request_data += "}";
   
   if(EnableAPILog) {
      Print("=== DeepSeek API请求 ===");
      Print("URL: ", DeepSeekBaseURL);
      Print("请求数据: ", request_data);
   }
   
   // 发送HTTP请求
   uchar result[];
   string result_headers;
   int response_code;
   
   int res = WebRequest("POST", DeepSeekBaseURL, headers, APITimeout, request_data, result, result_headers, response_code);
   
   if(res == -1) {
      string error_message = "WebRequest错误: " + IntegerToString(GetLastError());
      if(EnableDetailedLog) Print(error_message);
      
      // 模拟响应
      decision.action = "HOLD";
      decision.confidence = 0.5;
      decision.reasoning = "API请求失败: " + error_message;
      return false;
   }
   
   if(response_code != 200) {
      string error_msg = "HTTP错误代码: " + IntegerToString(response_code);
      if(EnableDetailedLog) Print(error_msg);
      
      decision.action = "HOLD";
      decision.confidence = 0.5;
      decision.reasoning = "API响应错误: " + error_msg;
      return false;
   }
   
   string response_text = CharArrayToString(result);
   
   if(EnableAPILog) {
      Print("API响应: ", response_text);
      Print("响应头: ", result_headers);
      Print("响应代码: ", IntegerToString(response_code));
   }
   
   // 解析AI响应
   return ParseAIResponse(response_text, decision);
}

//+------------------------------------------------------------------+
//| 解析AI响应函数                                                   |
//+------------------------------------------------------------------+
bool ParseAIResponse(string response, AITradingDecision &decision)
{
   // 简化的响应解析
   // 实际中需要完整解析JSON响应
   
   decision.action = "HOLD";
   decision.confidence = 0.5;
   decision.reasoning = "默认分析";
   
   if(StringFind(response, "\"action\":\"OPEN\"") >= 0) {
      decision.action = "OPEN";
   } else if(StringFind(response, "\"action\":\"CLOSE\"") >= 0) {
      decision.action = "CLOSE";
   }
   
   if(StringFind(response, "\"direction\":\"BUY\"") >= 0) {
      decision.direction = "BUY";
   } else if(StringFind(response, "\"direction\":\"SELL\"") >= 0) {
      decision.direction = "SELL";
   }
   
   // 提取置信度
   int confStart = StringFind(response, "\"confidence\":");
   if(confStart >= 0) {
      confStart += 13;
      int confEnd = StringFind(response, ",", confStart);
      if(confEnd < 0) confEnd = StringFind(response, "}", confStart);
      if(confEnd > confStart) {
         string confStr = StringSubstr(response, confStart, confEnd - confStart);
         decision.confidence = StringToDouble(confStr);
      }
   }
   
   // 提取理由
   int reasonStart = StringFind(response, "\"reasoning\":\"");
   if(reasonStart >= 0) {
      reasonStart += 13;
      int reasonEnd = StringFind(response, "\"", reasonStart);
      if(reasonEnd > reasonStart) {
         decision.reasoning = StringSubstr(response, reasonStart, reasonEnd - reasonStart);
      }
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| 执行AI决策函数                                                   |
//+------------------------------------------------------------------+
void ExecuteAIDecision(AITradingDecision &decision)
{
   if(decision.action == "HOLD") {
      Print("AI决策: 保持观望 - ", decision.reasoning);
      return;
   }
   
   if(decision.action == "OPEN") {
      ExecuteAIOpenDecision(decision);
   } else if(decision.action == "CLOSE") {
      ExecuteAICloseDecision(decision);
   }
}

//+------------------------------------------------------------------+
//| 执行AI开仓决策函数                                               |
//+------------------------------------------------------------------+
void ExecuteAIOpenDecision(AITradingDecision &decision)
{
   if(DailyTradeCount >= MaxDailyTrades) {
      Print("达到每日交易次数限制");
      return;
   }
   
   if(decision.symbol == "" || decision.direction == "") {
      Print("AI决策缺少必要参数");
      return;
   }
   
   int symbolIndex = GetSymbolIndex(decision.symbol);
   if(symbolIndex < 0) {
      Print("无效的交易品种: ", decision.symbol);
      return;
   }
   
   // 计算风险参数
   double lotSize = CalculateAILotSize(decision.symbol, decision.confidence);
   double stopLoss = CalculateAISL(decision.symbol, decision.direction, symbolIndex);
   double takeProfit = CalculateAITP(decision.symbol, decision.direction, stopLoss, symbolIndex);
   
   string comment = "AI决策 | 置信度:" + DoubleToString(decision.confidence, 2) + 
                   " | 理由:" + decision.reasoning;
   
   if(ExecuteTrade(decision.symbol, decision.direction, lotSize, stopLoss, takeProfit, comment)) {
      Print("AI开仓成功: ", decision.direction, " ", decision.symbol);
      DailyTradeCount++;
      
      // 记录交易
      RecordTrade(decision.symbol, decision.direction, lotSize, 0, 
                 "AI决策", comment, stopLoss, takeProfit, 0);
   }
}

//+------------------------------------------------------------------+
//| 执行AI平仓决策函数                                               |
//+------------------------------------------------------------------+
void ExecuteAICloseDecision(AITradingDecision &decision)
{
   if(decision.closeAll) {
      CloseAllPositions();
      Print("AI平仓: 所有仓位已平仓");
   } else if(decision.closeSymbol != "") {
      CloseSymbolPositions(decision.closeSymbol, decision.closePositionType);
      Print("AI平仓: ", decision.closeSymbol, " 已平仓");
   }
}

//+------------------------------------------------------------------+
//| 计算AI手数大小函数                                               |
//+------------------------------------------------------------------+
double CalculateAILotSize(string symbol, double confidence)
{
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * SingleRiskPercent / 100 * confidence;
   
   double pointValue = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
   double stopLossPoints = 30.0; // 默认30点止损
   
   if(point > 0 && pointValue > 0) {
      double lotSize = riskAmount / (stopLossPoints * pointValue);
      
      // 调整到合法手数
      double minLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
      double maxLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
      double lotStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
      
      if(lotStep > 0) {
         lotSize = MathFloor(lotSize / lotStep) * lotStep;
      }
      
      lotSize = MathMax(minLot, MathMin(lotSize, maxLot));
      
      return lotSize;
   }
   
   return SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
}

//+------------------------------------------------------------------+
//| 计算AI止损函数                                                   |
//+------------------------------------------------------------------+
double CalculateAISL(string symbol, string direction, int symbolIndex)
{
   double atr = GetIndicatorValue(atrHandle[symbolIndex]);
   double price = (direction == "BUY") ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
   
   if(direction == "BUY") {
      return price - atr * M15ATRSLMultiplier;
   } else {
      return price + atr * M15ATRSLMultiplier;
   }
}

//+------------------------------------------------------------------+
//| 计算AI止盈函数                                                   |
//+------------------------------------------------------------------+
double CalculateAITP(string symbol, string direction, double stopLoss, int symbolIndex)
{
   double atr = GetIndicatorValue(atrHandle[symbolIndex]);
   double price = (direction == "BUY") ? SymbolInfoDouble(symbol, SYMBOL_BID) : SymbolInfoDouble(symbol, SYMBOL_ASK);
   
   if(direction == "BUY") {
      return price + atr * M15ATRTPMultiplier;
   } else {
      return price - atr * M15ATRTPMultiplier;
   }
}

//+------------------------------------------------------------------+
//| 转义JSON字符串函数                                               |
//+------------------------------------------------------------------+
string EscapeJSONString(string input)
{
   string output = input;
   StringReplace(output, "\\", "\\\\");
   StringReplace(output, "\"", "\\\"");
   StringReplace(output, "/", "\\/");
   StringReplace(output, "\b", "\\b");
   StringReplace(output, "\f", "\\f");
   StringReplace(output, "\n", "\\n");
   StringReplace(output, "\r", "\\r");
   StringReplace(output, "\t", "\\t");
   return output;
}

//+------------------------------------------------------------------+
//| 关闭所有仓位函数                                                 |
//+------------------------------------------------------------------+
void CloseAllPositions()
{
   for(int i = PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         trade.PositionClose(ticket);
         Print("平仓: ", PositionGetString(POSITION_SYMBOL));
      }
   }
}

//+------------------------------------------------------------------+
//| 关闭指定品种仓位函数                                             |
//+------------------------------------------------------------------+
void CloseSymbolPositions(string symbol, int positionType = -1)
{
   for(int i = PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string posSymbol = PositionGetString(POSITION_SYMBOL);
         long posType = PositionGetInteger(POSITION_TYPE);
         
         if(posSymbol == symbol && (positionType == -1 || posType == positionType)) {
            trade.PositionClose(ticket);
            Print("平仓: ", symbol);
            
            // 记录平仓信息
            RecordTradeClose(symbol, posType == POSITION_TYPE_BUY ? "BUY" : "SELL", 
                           PositionGetDouble(POSITION_VOLUME), PositionGetDouble(POSITION_PROFIT));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| 记录平仓交易函数                                                 |
//+------------------------------------------------------------------+
void RecordTradeClose(string symbol, string direction, double volume, double profit)
{
   if(TradeRecordCount >= 1000) return;
   
   // 查找对应的开仓记录并更新盈亏
   for(int i = 0; i < TradeRecordCount; i++) {
      if(TradeHistory[i].Symbol == symbol && 
         TradeHistory[i].Direction == direction &&
         TradeHistory[i].Profit == 0) { // 未平仓记录
         
         TradeHistory[i].Profit = profit;
         TradeHistory[i].HoldTime = (int)((TimeCurrent() - TradeHistory[i].Time) / 60); // 分钟
         break;
      }
   }
}

//+------------------------------------------------------------------+
//| 检查是否持仓函数                                                 |
//+------------------------------------------------------------------+
bool HasPosition(string symbol)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(PositionGetSymbol(i) == symbol) return true;
   }
   return false;
}

//+------------------------------------------------------------------+
//| 检查交易条件函数                                                 |
//+------------------------------------------------------------------+
bool CheckTradeConditions(string symbol)
{
   if(HasPosition(symbol)) {
      if(EnableDetailedLog) Print("跳过 ", symbol, " - 已有持仓");
      return false;
   }
   
   if(DailyTradeCount >= MaxDailyTrades) {
      if(EnableDetailedLog) Print("跳过 ", symbol, " - 达到每日交易限制");
      return false;
   }
   
   if(SystemError) {
      if(EnableDetailedLog) Print("跳过 ", symbol, " - 系统错误");
      return false;
   }
   
   if(IsResting()) {
      if(EnableDetailedLog) Print("跳过 ", symbol, " - 系统休息期");
      return false;
   }
   
   // 检查交易时间
   if(!IsTradingTime(symbol)) {
      if(EnableDetailedLog) Print("跳过 ", symbol, " - 非交易时间");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| 检查是否在休息期函数                                             |
//+------------------------------------------------------------------+
bool IsResting()
{
   return (RestStartTime > 0 && TimeCurrent() - RestStartTime < 24 * 3600);
}

//+------------------------------------------------------------------+
//| 检查是否可以交易函数                                             |
//+------------------------------------------------------------------+
bool CanTrade()
{
   return (DailyTradeCount < MaxDailyTrades && !SystemError && !IsResting());
}

//+------------------------------------------------------------------+
//| 检查交易时间函数                                                 |
//+------------------------------------------------------------------+
bool IsTradingTime(string symbol)
{
   // 获取当前时间
   MqlDateTime timeNow;
   TimeToStruct(TimeCurrent(), timeNow);
   
   // 简单的交易时间检查
   // 周一至周五，避开重要数据发布时间
   if(timeNow.day_of_week == 0 || timeNow.day_of_week == 6) { // 周末
      return false;
   }
   
   // 避开市场关闭时间（根据品种调整）
   if(StringFind(symbol, "XAU") >= 0) {
      // 黄金交易时间检查
      if(timeNow.hour < 1 || timeNow.hour > 23) return false;
   } else {
      // 外汇交易时间检查
      if(timeNow.hour < 2 || timeNow.hour > 22) return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| 记录AI分析函数                                                   |
//+------------------------------------------------------------------+
void RecordAIAnalysis(string symbol, TradeSignal &Signal)
{
   if(!EnableDetailedLog) return;

   Print("=== AI分析报告 [", symbol, "] ===");
   Print("最终决策: ", Signal.Direction);
   Print("策略数量: ", Signal.ValidStrategyCount);
   Print("趋势强度: ", Signal.Strength, "/100");
   Print("AI置信度: ", DoubleToString(Signal.Confidence, 2));
   Print("决策理由: ", Signal.Reason);

   // 输出每个策略的详细信号
   for(int i = 0; i < Signal.ValidStrategyCount; i++) {
      Print("策略", i+1, ": ", Signal.StrategyArray[i].StrategyName,
            " 方向: ", Signal.StrategyArray[i].SignalDirection,
            " 强度: ", Signal.StrategyArray[i].SignalStrength,
            " 置信度: ", DoubleToString(Signal.StrategyArray[i].Confidence, 2),
            " 预估胜率: ", DoubleToString(Signal.StrategyArray[i].EstimatedWinRate, 1), "%",
            " 理由: ", Signal.StrategyArray[i].DecisionReason);
   }

   Print("=======================");
}

//+------------------------------------------------------------------+
//| 计算风险函数                                                     |
//+------------------------------------------------------------------+
bool CalculateRisk(string symbol, TradeSignal &Signal, double &LotSize, double &StopLoss, double &TakeProfit, int symbolIndex)
{
   double AccountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(AccountBalance <= 0) return false;
   
   double RiskAmount = AccountBalance * SingleRiskPercent / 100;
   double atrValue = GetIndicatorValue(atrHandle[symbolIndex]);
   double PointValue = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
   double MinLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
   double MaxLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   double Point = SymbolInfoDouble(symbol, SYMBOL_POINT);
   double CurrentPrice = SymbolInfoDouble(symbol, SYMBOL_BID);
   double LotStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
   
   if(Point <= 0) return false;
   if(atrValue <= 0) atrValue = 0.001;
   if(PointValue <= 0) PointValue = 10.0;
   if(MinLot <= 0) MinLot = 0.01;
   
   double StopLossPoints, TakeProfitPoints;

   if(EnableAdaptiveSLTP) {
      if(MainTF == PERIOD_M15) {
         StopLossPoints = atrValue * M15ATRSLMultiplier / Point;
         TakeProfitPoints = atrValue * M15ATRTPMultiplier / Point;
      } else {
         StopLossPoints = atrValue * H1ATRSLMultiplier / Point;
         TakeProfitPoints = atrValue * H1ATRTPMultiplier / Point;
      }
   } else {
      StopLossPoints = atrValue * 2.0 / Point;
      TakeProfitPoints = atrValue * 4.0 / Point;
   }
   
   if(StopLossPoints <= 0) StopLossPoints = 30.0;
   if(TakeProfitPoints <= 0) TakeProfitPoints = StopLossPoints * 2.0;
   
   if(StopLossPoints > 0 && PointValue > 0) {
      LotSize = RiskAmount / (StopLossPoints * PointValue);
   } else {
      LotSize = MinLot;
   }
   
   if(LotStep > 0) {
      LotSize = MathFloor(LotSize / LotStep) * LotStep;
   }
   
   LotSize = MathMax(MinLot, MathMin(LotSize, MaxLot));
   
   if(Signal.Direction == "BUY") {
      StopLoss = CurrentPrice - StopLossPoints * Point;
      TakeProfit = CurrentPrice + TakeProfitPoints * Point;
   } else if(Signal.Direction == "SELL") {
      StopLoss = CurrentPrice + StopLossPoints * Point;
      TakeProfit = CurrentPrice - TakeProfitPoints * Point;
   } else {
      return false;
   }
   
   double MinStopLevel = SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL) * Point;
   
   if(Signal.Direction == "BUY") {
      if(CurrentPrice - StopLoss < MinStopLevel) {
         StopLoss = CurrentPrice - MinStopLevel;
      }
      if(TakeProfit - CurrentPrice < MinStopLevel) {
         TakeProfit = CurrentPrice + MinStopLevel;
      }
   } else if(Signal.Direction == "SELL") {
      if(StopLoss - CurrentPrice < MinStopLevel) {
         StopLoss = CurrentPrice + MinStopLevel;
      }
      if(CurrentPrice - TakeProfit < MinStopLevel) {
         TakeProfit = CurrentPrice - MinStopLevel;
      }
   }
   
   if(EnableDetailedLog) {
      Print("=== 风险计算详情 ===");
      Print("品种: ", symbol);
      Print("ATR值: ", atrValue);
      Print("止损点数: ", StopLossPoints);
      Print("止盈点数: ", TakeProfitPoints);
      Print("计算手数: ", LotSize);
      Print("计算止损价: ", StopLoss);
      Print("计算止盈价: ", TakeProfit);
      Print("最小止损距离: ", MinStopLevel);
      Print("=======================");
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| 执行交易函数                                                     |
//+------------------------------------------------------------------+
bool ExecuteTrade(string symbol, string Direction, double LotSize, double StopLoss, double TakeProfit, string comment)
{
   if(!CheckMaxPosition(symbol, LotSize)) {
      Print("手数检查失败: ", symbol, " 手数: ", LotSize);
      return false;
   }
   
   MqlTradeRequest Request;
   MqlTradeResult Result;
   ZeroMemory(Request);
   ZeroMemory(Result);
   
   Request.action = TRADE_ACTION_DEAL;
   Request.symbol = symbol;
   Request.volume = LotSize;
   if(StopLoss > 0) Request.sl = NormalizeDouble(StopLoss, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
   if(TakeProfit > 0) Request.tp = NormalizeDouble(TakeProfit, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
   Request.deviation = 10;
   Request.magic = 2025;
   Request.comment = comment;
   
   if(Direction == "BUY") {
      Request.type = ORDER_TYPE_BUY;
      Request.price = NormalizeDouble(SymbolInfoDouble(symbol, SYMBOL_ASK), (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
   } else {
      Request.type = ORDER_TYPE_SELL;
      Request.price = NormalizeDouble(SymbolInfoDouble(symbol, SYMBOL_BID), (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
   }
   
   bool Success = OrderSend(Request, Result);
   if(Success && Result.retcode == TRADE_RETCODE_DONE) {
      Print("交易成功: ", Direction, " ", symbol, " 手数:", LotSize, " 注释:", comment);
      return true;
   } else {
      Print("交易失败: ", Direction, " ", symbol, " 错误代码:", Result.retcode, " 错误描述:", GetRetcodeDescription(Result.retcode));
      return false;
   }
}

//+------------------------------------------------------------------+
//| 检查最大仓位函数                                                 |
//+------------------------------------------------------------------+
bool CheckMaxPosition(string symbol, double lotSize)
{
   double MinLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
   double MaxLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   return (lotSize >= MinLot && lotSize <= MaxLot);
}

//+------------------------------------------------------------------+
//| 错误代码描述函数                                                 |
//+------------------------------------------------------------------+
string GetRetcodeDescription(int retcode)
{
   switch(retcode) {
      case 0:     return "成功";
      case 10004: return "TRADE_RETCODE_REQUOTE";
      case 10006: return "TRADE_RETCODE_REJECT";
      case 10007: return "TRADE_RETCODE_CANCEL";
      case 10008: return "TRADE_RETCODE_PLACED";
      case 10009: return "TRADE_RETCODE_DONE";
      case 10010: return "TRADE_RETCODE_DONE_PARTIAL";
      case 10011: return "TRADE_RETCODE_ERROR";
      case 10012: return "TRADE_RETCODE_TIMEOUT";
      case 10013: return "TRADE_RETCODE_INVALID";
      case 10014: return "TRADE_RETCODE_INVALID_VOLUME";
      case 10015: return "TRADE_RETCODE_INVALID_PRICE";
      case 10016: return "TRADE_RETCODE_INVALID_STOPS";
      case 10017: return "TRADE_RETCODE_TRADE_DISABLED";
      case 10018: return "TRADE_RETCODE_MARKET_CLOSED";
      case 10019: return "TRADE_RETCODE_NO_MONEY";
      case 10020: return "TRADE_RETCODE_PRICE_CHANGED";
      case 10021: return "TRADE_RETCODE_PRICE_OFF";
      default:    return "未知错误代码 (" + IntegerToString(retcode) + ")";
   }
}

//+------------------------------------------------------------------+
//| 记录交易函数                                                     |
//+------------------------------------------------------------------+
void RecordTrade(string symbol, string direction, double volume, double profit, 
                 string strategy, string comment, double sl, double tp, int holdTime)
{
   if(TradeRecordCount >= 1000) return;
   
   TradeHistory[TradeRecordCount].Time = TimeCurrent();
   TradeHistory[TradeRecordCount].Symbol = symbol;
   TradeHistory[TradeRecordCount].Direction = direction;
   TradeHistory[TradeRecordCount].Volume = volume;
   TradeHistory[TradeRecordCount].Profit = profit;
   TradeHistory[TradeRecordCount].Strategy = strategy;
   TradeHistory[TradeRecordCount].Comment = comment;
   TradeHistory[TradeRecordCount].SL = sl;
   TradeHistory[TradeRecordCount].TP = tp;
   TradeHistory[TradeRecordCount].HoldTime = holdTime;
   
   TradeRecordCount++;
   
   // 定期保存到文件
   if(TradeRecordCount % 50 == 0) {
      SaveTradeHistory();
   }
}

//+------------------------------------------------------------------+
//| 保存交易历史函数                                                 |
//+------------------------------------------------------------------+
void SaveTradeHistory()
{
   int handle = FileOpen("TradeHistory.txt", FILE_WRITE|FILE_TXT|FILE_COMMON);
   if(handle == INVALID_HANDLE) return;
   
   for(int i = 0; i < TradeRecordCount; i++) {
      FileWrite(handle, 
               TimeToString(TradeHistory[i].Time),
               TradeHistory[i].Symbol,
               TradeHistory[i].Direction,
               DoubleToString(TradeHistory[i].Volume, 2),
               DoubleToString(TradeHistory[i].Profit, 2),
               TradeHistory[i].Strategy,
               TradeHistory[i].Comment,
               DoubleToString(TradeHistory[i].SL, 5),
               DoubleToString(TradeHistory[i].TP, 5),
               IntegerToString(TradeHistory[i].HoldTime)
      );
   }
   
   FileClose(handle);
   Print("交易历史已保存，记录数: ", TradeRecordCount);
}

//+------------------------------------------------------------------+
//| 检查风险管理函数                                                 |
//+------------------------------------------------------------------+
void CheckRiskManagement()
{
   double TotalProfit = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong Ticket = PositionGetTicket(i);
      if(Ticket > 0 && PositionSelectByTicket(Ticket)) {
         TotalProfit += PositionGetDouble(POSITION_PROFIT);
      }
   }

   if(TotalProfit < 0) {
      DailyLoss += -TotalProfit;
      ConsecutiveLosses++;
   } else {
      ConsecutiveLosses = 0;
   }

   if(ConsecutiveLosses >= MaxConsecutiveLosses) {
      RestStartTime = TimeCurrent();
      Print("连续亏损达到限制，系统进入休息期");
   }

   // 检查资金保护
   CheckCapitalProtection();
}

//+------------------------------------------------------------------+
//| 检查资金保护函数                                                 |
//+------------------------------------------------------------------+
void CheckCapitalProtection()
{
   double AccountEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double AccountBalance = AccountInfoDouble(ACCOUNT_BALANCE);

   if(AccountBalance == 0) return;

   double DrawdownPercent = (AccountBalance - AccountEquity) / AccountBalance * 100;

   if(DrawdownPercent > MaxDailyDrawdownPercent) {
      SystemError = true;
      ErrorReason = "资金回撤超过" + DoubleToString(MaxDailyDrawdownPercent, 1) + "%";
      Print("!!! 风控触发: " + ErrorReason);
   }
}

//+------------------------------------------------------------------+
//| 检查复盘时机函数                                                 |
//+------------------------------------------------------------------+
void CheckReviewTiming()
{
   datetime CurrentTime = TimeCurrent();
   MqlDateTime TimeStruct;
   TimeToStruct(CurrentTime, TimeStruct);
   
   // 每日复盘
   if(EnableDailyReview && TimeStruct.hour == DailyReviewHour && TimeStruct.min == 0) {
      if(CurrentTime - LastDailyReviewTime >= 86400) {
         ExecuteDailyReview();
         LastDailyReviewTime = CurrentTime;
      }
   }
   
   // 每周复盘
   if(EnableWeeklyReview && TimeStruct.day_of_week == WeeklyReviewDay && TimeStruct.hour == DailyReviewHour) {
      if(CurrentTime - LastWeeklyReviewTime >= 604800) {
         ExecuteWeeklyReview();
         LastWeeklyReviewTime = CurrentTime;
      }
   }
   
   // 每月复盘
   if(EnableMonthlyReview && TimeStruct.day == MonthlyReviewDay && TimeStruct.hour == DailyReviewHour) {
      if(CurrentTime - LastMonthlyReviewTime >= 2592000) {
         ExecuteMonthlyReview();
         LastMonthlyReviewTime = CurrentTime;
      }
   }
}

//+------------------------------------------------------------------+
//| 执行每日复盘函数                                                 |
//+------------------------------------------------------------------+
void ExecuteDailyReview()
{
   Print("=== 开始每日复盘 ===");
   
   datetime StartTime = TimeCurrent() - 86400;
   datetime EndTime = TimeCurrent();
   
   ReviewStatistics Stats = CalculatePeriodStats(StartTime, EndTime);
   string ReportContent = GenerateDailyReport(Stats);
   
   string FileName = "DailyReview_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt";
   SaveReport(FileName, ReportContent);
   
   if(EnableAIAnalysis) {
      string AIAnalysis = GetReviewAIAnalysis(Stats, "每日");
      Print("AI每日分析: ", AIAnalysis);
      SaveReport("AIAnalysis_Daily_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt", AIAnalysis);
   }
   
   Print("每日复盘完成");
}

//+------------------------------------------------------------------+
//| 执行每周复盘函数                                                 |
//+------------------------------------------------------------------+
void ExecuteWeeklyReview()
{
   Print("=== 开始每周复盘 ===");
   
   datetime WeekStart = iTime(Symbol(), PERIOD_W1, 0);
   datetime WeekEnd = TimeCurrent();
   
   ReviewStatistics WeekStats = CalculatePeriodStats(WeekStart, WeekEnd);
   string ReportContent = GenerateWeeklyReport(WeekStats);
   
   string FileName = "WeeklyReview_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt";
   SaveReport(FileName, ReportContent);
   
   if(EnableAIAnalysis) {
      string AIAnalysis = GetReviewAIAnalysis(WeekStats, "每周");
      Print("AI每周分析: ", AIAnalysis);
      SaveReport("AIAnalysis_Weekly_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt", AIAnalysis);
   }
   
   Print("每周复盘完成");
}

//+------------------------------------------------------------------+
//| 执行每月复盘函数                                                 |
//+------------------------------------------------------------------+
void ExecuteMonthlyReview()
{
   Print("=== 开始每月复盘 ===");
   
   datetime MonthStart = iTime(Symbol(), PERIOD_MN1, 0);
   datetime MonthEnd = TimeCurrent();
   
   ReviewStatistics MonthStats = CalculatePeriodStats(MonthStart, MonthEnd);
   string ReportContent = GenerateMonthlyReport(MonthStats);
   
   string FileName = "MonthlyReview_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt";
   SaveReport(FileName, ReportContent);
   
   if(EnableAIAnalysis) {
      string AIAnalysis = GetReviewAIAnalysis(MonthStats, "每月");
      Print("AI每月分析: ", AIAnalysis);
      SaveReport("AIAnalysis_Monthly_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt", AIAnalysis);
   }
   
   Print("每月复盘完成");
}

//+------------------------------------------------------------------+
//| 计算周期统计函数                                                 |
//+------------------------------------------------------------------+
ReviewStatistics CalculatePeriodStats(datetime StartTime, datetime EndTime)
{
   ReviewStatistics Stats;
   Stats.StartTime = StartTime;
   Stats.EndTime = EndTime;
   Stats.TotalTrades = 0;
   Stats.WinTrades = 0;
   Stats.LossTrades = 0;
   Stats.TotalProfit = 0;
   Stats.MaxWinStreak = 0;
   Stats.MaxLossStreak = 0;
   Stats.MaxDrawdown = 0;
   
   int CurrentWinStreak = 0;
   int CurrentLossStreak = 0;
   double MaxEquity = 0;
   double CurrentEquity = 0;
   
   for(int i = 0; i < TradeRecordCount; i++) {
      if(TradeHistory[i].Time >= StartTime && TradeHistory[i].Time <= EndTime) {
         Stats.TotalTrades++;
         Stats.TotalProfit += TradeHistory[i].Profit;
         
         if(TradeHistory[i].Profit > 0) {
            Stats.WinTrades++;
            CurrentWinStreak++;
            CurrentLossStreak = 0;
            if(CurrentWinStreak > Stats.MaxWinStreak) Stats.MaxWinStreak = CurrentWinStreak;
         } else {
            Stats.LossTrades++;
            CurrentLossStreak++;
            CurrentWinStreak = 0;
            if(CurrentLossStreak > Stats.MaxLossStreak) Stats.MaxLossStreak = CurrentLossStreak;
         }
         
         CurrentEquity += TradeHistory[i].Profit;
         if(CurrentEquity > MaxEquity) MaxEquity = CurrentEquity;
         Stats.MaxDrawdown = MathMax(Stats.MaxDrawdown, MaxEquity - CurrentEquity);
      }
   }
   
   if(Stats.TotalTrades > 0) {
      Stats.WinRate = (double)Stats.WinTrades / Stats.TotalTrades * 100;
      Stats.AvgProfit = Stats.TotalProfit / Stats.TotalTrades;
      
      // 计算盈亏比
      double TotalWin = 0, TotalLoss = 0;
      for(int i = 0; i < TradeRecordCount; i++) {
         if(TradeHistory[i].Time >= StartTime && TradeHistory[i].Time <= EndTime) {
            if(TradeHistory[i].Profit > 0) TotalWin += TradeHistory[i].Profit;
            else TotalLoss += MathAbs(TradeHistory[i].Profit);
         }
      }
      
      if(TotalLoss > 0) {
         Stats.ProfitFactor = TotalWin / TotalLoss;
      } else {
         Stats.ProfitFactor = 0;
      }
   }
   
   return Stats;
}

//+------------------------------------------------------------------+
//| 生成每日报告函数                                                 |
//+------------------------------------------------------------------+
string GenerateDailyReport(ReviewStatistics &Stats)
{
   string Report = "=== 宇川AI交易系统每日复盘报告 ===\n\n";
   Report += "统计周期: " + TimeToString(Stats.StartTime) + " 至 " + TimeToString(Stats.EndTime) + "\n\n";

   Report += "当日交易概览\n";
   Report += "───────────────\n";
   Report += "总交易笔数: " + IntegerToString(Stats.TotalTrades) + "\n";
   Report += "盈利交易: " + IntegerToString(Stats.WinTrades) + "笔\n";
   Report += "亏损交易: " + IntegerToString(Stats.LossTrades) + "笔\n";
   Report += "胜率: " + DoubleToString(Stats.WinRate, 1) + "%\n";
   Report += "总盈亏: " + DoubleToString(Stats.TotalProfit, 2) + " USD\n";
   Report += "平均每笔盈亏: " + DoubleToString(Stats.AvgProfit, 2) + " USD\n";
   Report += "盈亏比: " + DoubleToString(Stats.ProfitFactor, 2) + "\n\n";

   Report += "风险指标\n";
   Report += "───────────────\n";
   Report += "最大连胜: " + IntegerToString(Stats.MaxWinStreak) + "笔\n";
   Report += "最大连败: " + IntegerToString(Stats.MaxLossStreak) + "笔\n";
   Report += "最大回撤: " + DoubleToString(Stats.MaxDrawdown, 2) + " USD\n\n";

   Report += "报告生成时间: " + TimeToString(TimeCurrent()) + "\n";

   return Report;
}

//+------------------------------------------------------------------+
//| 生成周报函数                                                     |
//+------------------------------------------------------------------+
string GenerateWeeklyReport(ReviewStatistics &Stats)
{
   string Report = "=== 宇川AI交易系统每周复盘报告 ===\n\n";
   Report += "统计周期: " + TimeToString(Stats.StartTime) + " 至 " + TimeToString(Stats.EndTime) + "\n\n";

   Report += "本周交易概览\n";
   Report += "───────────────\n";
   Report += "总交易笔数: " + IntegerToString(Stats.TotalTrades) + "\n";
   Report += "盈利交易: " + IntegerToString(Stats.WinTrades) + "笔\n";
   Report += "亏损交易: " + IntegerToString(Stats.LossTrades) + "笔\n";
   Report += "胜率: " + DoubleToString(Stats.WinRate, 1) + "%\n";
   Report += "总盈亏: " + DoubleToString(Stats.TotalProfit, 2) + " USD\n";
   Report += "平均每笔盈亏: " + DoubleToString(Stats.AvgProfit, 2) + " USD\n";
   Report += "盈亏比: " + DoubleToString(Stats.ProfitFactor, 2) + "\n\n";

   Report += "报告生成时间: " + TimeToString(TimeCurrent()) + "\n";

   return Report;
}

//+------------------------------------------------------------------+
//| 生成月报函数                                                     |
//+------------------------------------------------------------------+
string GenerateMonthlyReport(ReviewStatistics &Stats)
{
   string Report = "=== 宇川AI交易系统每月复盘报告 ===\n\n";
   Report += "统计周期: " + TimeToString(Stats.StartTime) + " 至 " + TimeToString(Stats.EndTime) + "\n\n";

   Report += "本月交易概览\n";
   Report += "───────────────\n";
   Report += "总交易笔数: " + IntegerToString(Stats.TotalTrades) + "\n";
   Report += "盈利交易: " + IntegerToString(Stats.WinTrades) + "笔\n";
   Report += "亏损交易: " + IntegerToString(Stats.LossTrades) + "笔\n";
   Report += "胜率: " + DoubleToString(Stats.WinRate, 1) + "%\n";
   Report += "总盈亏: " + DoubleToString(Stats.TotalProfit, 2) + " USD\n";
   Report += "平均每笔盈亏: " + DoubleToString(Stats.AvgProfit, 2) + " USD\n";
   Report += "盈亏比: " + DoubleToString(Stats.ProfitFactor, 2) + "\n\n";

   Report += "风险指标\n";
   Report += "───────────────\n";
   Report += "最大连胜: " + IntegerToString(Stats.MaxWinStreak) + "笔\n";
   Report += "最大连败: " + IntegerToString(Stats.MaxLossStreak) + "笔\n";
   Report += "最大回撤: " + DoubleToString(Stats.MaxDrawdown, 2) + " USD\n";
   Report += "月收益率: " + DoubleToString(Stats.TotalProfit / AccountInfoDouble(ACCOUNT_BALANCE) * 100, 2) + "%\n\n";

   // 策略表现分析
   Report += "策略表现分析\n";
   Report += "───────────────\n";
   Report += AnalyzeStrategyPerformance(Stats.StartTime, Stats.EndTime) + "\n";

   // 资金管理分析
   Report += "资金管理分析\n";
   Report += "───────────────\n";
   Report += AnalyzeMoneyManagement(Stats.StartTime, Stats.EndTime) + "\n";

   // 市场环境分析
   Report += "市场环境分析\n";
   Report += "───────────────\n";
   Report += AnalyzeMarketEnvironment(Stats.StartTime, Stats.EndTime) + "\n";

   // 下月建议
   Report += "下月交易建议\n";
   Report += "───────────────\n";
   Report += GenerateNextMonthSuggestion(Stats) + "\n";

   Report += "报告生成时间: " + TimeToString(TimeCurrent()) + "\n";

   return Report;
}

//+------------------------------------------------------------------+
//| 分析策略表现函数                                                 |
//+------------------------------------------------------------------+
string AnalyzeStrategyPerformance(datetime StartTime, datetime EndTime)
{
   string analysis = "策略表现详情:\n";
   
   // 统计各策略表现
   string strategies[] = {"趋势跟踪", "均值回归", "海龟交易", "123法则", "裸K", 
                          "波动率突破", "布林带", "SMC", "金叉死叉", "机器学习"};
   
   int totalTrades = 0;
   double totalProfit = 0;
   
   for(int i = 0; i < TradeRecordCount; i++) {
      if(TradeHistory[i].Time >= StartTime && TradeHistory[i].Time <= EndTime) {
         totalTrades++;
         totalProfit += TradeHistory[i].Profit;
      }
   }
   
   if(totalTrades == 0) {
      return "统计周期内无交易";
   }
   
   analysis += "总交易次数: " + IntegerToString(totalTrades) + "\n";
   analysis += "总盈亏: " + DoubleToString(totalProfit, 2) + " USD\n";
   analysis += "平均每笔盈亏: " + DoubleToString(totalProfit / totalTrades, 2) + " USD\n\n";
   
   // 按策略分类统计
   analysis += "按策略分类:\n";
   
   for(int s = 0; s < ArraySize(strategies); s++) {
      int count = 0;
      double profit = 0;
      int wins = 0;
      
      for(int i = 0; i < TradeRecordCount; i++) {
         if(TradeHistory[i].Time >= StartTime && TradeHistory[i].Time <= EndTime) {
            if(TradeHistory[i].Strategy == strategies[s]) {
               count++;
               profit += TradeHistory[i].Profit;
               if(TradeHistory[i].Profit > 0) wins++;
            }
         }
      }
      
      if(count > 0) {
         double winRate = (double)wins / count * 100;
         analysis += strategies[s] + ": " + IntegerToString(count) + "笔, " +
                    DoubleToString(profit, 2) + " USD, " +
                    DoubleToString(profit / count, 2) + "平均盈亏, " +
                    DoubleToString(winRate, 1) + "%胜率\n";
      }
   }
   
   return analysis;
}

//+------------------------------------------------------------------+
//| 分析资金管理函数                                                 |
//+------------------------------------------------------------------+
string AnalyzeMoneyManagement(datetime StartTime, datetime EndTime)
{
   string analysis = "资金管理分析:\n\n";
   
   double initialBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double finalBalance = initialBalance;
   double maxBalance = initialBalance;
   double minBalance = initialBalance;
   double totalProfit = 0;
   double totalLoss = 0;
   
   // 模拟资金曲线
   for(int i = 0; i < TradeRecordCount; i++) {
      if(TradeHistory[i].Time >= StartTime && TradeHistory[i].Time <= EndTime) {
         finalBalance += TradeHistory[i].Profit;
         totalProfit += MathMax(0, TradeHistory[i].Profit);
         totalLoss += MathAbs(MathMin(0, TradeHistory[i].Profit));
         
         if(finalBalance > maxBalance) maxBalance = finalBalance;
         if(finalBalance < minBalance) minBalance = finalBalance;
      }
   }
   
   analysis += "初始资金: " + DoubleToString(initialBalance, 2) + " USD\n";
   analysis += "最终资金: " + DoubleToString(finalBalance, 2) + " USD\n";
   analysis += "最高资金: " + DoubleToString(maxBalance, 2) + " USD\n";
   analysis += "最低资金: " + DoubleToString(minBalance, 2) + " USD\n";
   analysis += "绝对收益: " + DoubleToString(finalBalance - initialBalance, 2) + " USD\n";
   analysis += "相对收益: " + DoubleToString((finalBalance - initialBalance) / initialBalance * 100, 2) + "%\n\n";
   
   analysis += "盈亏分析:\n";
   analysis += "总盈利: " + DoubleToString(totalProfit, 2) + " USD\n";
   analysis += "总亏损: " + DoubleToString(totalLoss, 2) + " USD\n";
   analysis += "盈亏比: " + (totalLoss > 0 ? DoubleToString(totalProfit / totalLoss, 2) : "无限") + "\n\n";
   
   // 资金曲线分析
   analysis += "资金曲线分析:\n";
   if(finalBalance > initialBalance * 1.15) {
      analysis += "资金曲线表现优秀，稳定向上增长\n";
   } else if(finalBalance > initialBalance) {
      analysis += "资金曲线表现良好，稳步增长\n";
   } else if(finalBalance > initialBalance * 0.85) {
      analysis += "资金曲线表现一般，需要优化\n";
   } else {
      analysis += "资金曲线表现较差，需要重大调整\n";
   }
   
   // 回撤分析
   double maxDrawdown = (maxBalance - minBalance) / maxBalance * 100;
   analysis += "最大回撤: " + DoubleToString(maxDrawdown, 1) + "% - ";
   if(maxDrawdown < 10) analysis += "优秀的风控表现";
   else if(maxDrawdown < 20) analysis += "良好的风控表现";
   else if(maxDrawdown < 30) analysis += "一般的风控表现";
   else analysis += "较差的风控表现";
   analysis += "\n\n";
   
   return analysis;
}

//+------------------------------------------------------------------+
//| 分析市场环境函数                                                 |
//+------------------------------------------------------------------+
string AnalyzeMarketEnvironment(datetime StartTime, datetime EndTime)
{
   string analysis = "市场环境分析:\n";
   
   // 简化的市场环境分析
   int trendDays = 0;
   int rangeDays = 0;
   int breakoutDays = 0;
   
   datetime current = StartTime;
   while(current <= EndTime) {
      ENUM_MARKET_STATE state = AnalyzeMarketState(Symbol(), 0);
      
      switch(state) {
         case MARKET_TREND: trendDays++; break;
         case MARKET_RANGE: rangeDays++; break;
         case MARKET_BREAKOUT: breakoutDays++; break;
      }
      
      current += 86400; // 增加一天
   }
   
   int totalDays = (int)((EndTime - StartTime) / 86400) + 1;
   
   analysis += "统计天数: " + IntegerToString(totalDays) + "\n";
   analysis += "趋势市天数: " + IntegerToString(trendDays) + " (" + 
              DoubleToString((double)trendDays / totalDays * 100, 1) + "%)\n";
   analysis += "震荡市天数: " + IntegerToString(rangeDays) + " (" + 
              DoubleToString((double)rangeDays / totalDays * 100, 1) + "%)\n";
   analysis += "突破市天数: " + IntegerToString(breakoutDays) + " (" + 
              DoubleToString((double)breakoutDays / totalDays * 100, 1) + "%)\n\n";
   
   analysis += "市场环境建议:\n";
   
   if(trendDays > rangeDays + breakoutDays) {
      analysis += "当前市场以趋势为主，建议:\n";
      analysis += "1. 优先使用趋势跟踪策略\n";
      analysis += "2. 增加趋势策略的权重配置\n";
      analysis += "3. 适当放宽止损设置，让利润奔跑\n";
   } else if(rangeDays > trendDays + breakoutDays) {
      analysis += "当前市场以震荡为主，建议:\n";
      analysis += "1. 优先使用均值回归策略\n";
      analysis += "2. 收紧止损设置，控制单笔亏损\n";
      analysis += "3. 采用网格或马丁策略（谨慎使用）\n";
   } else if(breakoutDays > trendDays + rangeDays) {
      analysis += "当前市场以突破为主，建议:\n";
      analysis += "1. 优先使用突破策略\n";
      analysis += "2. 关注关键支撑阻力位的突破\n";
      analysis += "3. 适当放宽止损，避免被震荡洗出\n";
   } else {
      analysis += "市场状态混合，建议:\n";
      analysis += "1. 采用多策略组合\n";
      analysis += "2. 动态调整策略权重\n";
      analysis += "3. 加强风险控制\n";
   }
   
   return analysis;
}

//+------------------------------------------------------------------+
//| 生成下月建议函数                                                 |
//+------------------------------------------------------------------+
string GenerateNextMonthSuggestion(ReviewStatistics &Stats)
{
   string suggestions = "";
   
   double monthlyReturn = Stats.TotalProfit / AccountInfoDouble(ACCOUNT_BALANCE) * 100;
   
   if(monthlyReturn >= 5) {
      suggestions = "本月表现优秀，建议下月:\n";
      suggestions += "1. 保持策略稳定性\n";
      suggestions += "2. 逐步增加资金规模\n";
      suggestions += "3. 优化高胜率策略\n";
   } else if(monthlyReturn >= 0) {
      suggestions = "本月表现稳定，建议下月:\n";
      suggestions += "1. 微调策略参数\n";
      suggestions += "2. 保持资金规模\n";
      suggestions += "3. 加强风险控制\n";
   } else {
      suggestions = "本月出现亏损，建议下月:\n";
      suggestions += "1. 重新评估所有策略\n";
      suggestions += "2. 减少资金规模\n";
      suggestions += "3. 严格执行风控规则\n";
   }
   
   suggestions += "\n长期规划建议:\n";
   suggestions += "- 年度目标收益率: 20%-30%\n";
   suggestions += "- 最大回撤控制: 15%以内\n";
   suggestions += "- 策略多元化: 3-5种核心策略\n";
   suggestions += "- 定期复盘: 每周/每月\n";
   
   return suggestions;
}

//+------------------------------------------------------------------+
//| 保存报告函数                                                     |
//+------------------------------------------------------------------+
void SaveReport(string FileName, string Content)
{
   int FileHandle = FileOpen(ReportSavePath + FileName, FILE_WRITE|FILE_TXT|FILE_COMMON);
   if(FileHandle != INVALID_HANDLE) {
      FileWrite(FileHandle, Content);
      FileClose(FileHandle);
      Print("报告已保存: ", ReportSavePath + FileName);
   } else {
      Print("错误: 无法保存报告 ", ReportSavePath + FileName);
   }
}

//+------------------------------------------------------------------+
//| 获取复盘AI分析函数                                               |
//+------------------------------------------------------------------+
string GetReviewAIAnalysis(ReviewStatistics &Stats, string Period)
{
   string prompt = "你是一名专业量化交易分析师，请基于以下交易统计数据给出分析建议：\n\n";
   
   prompt += "=== " + Period + "交易统计 ===\n";
   prompt += "总交易笔数: " + IntegerToString(Stats.TotalTrades) + "\n";
   prompt += "盈利交易: " + IntegerToString(Stats.WinTrades) + "笔\n";
   prompt += "亏损交易: " + IntegerToString(Stats.LossTrades) + "笔\n";
   prompt += "胜率: " + DoubleToString(Stats.WinRate, 1) + "%\n";
   prompt += "总盈亏: " + DoubleToString(Stats.TotalProfit, 2) + " USD\n";
   prompt += "平均每笔盈亏: " + DoubleToString(Stats.AvgProfit, 2) + " USD\n";
   prompt += "盈亏比: " + DoubleToString(Stats.ProfitFactor, 2) + "\n";
   prompt += "最大连胜: " + IntegerToString(Stats.MaxWinStreak) + "笔\n";
   prompt += "最大连败: " + IntegerToString(Stats.MaxLossStreak) + "笔\n";
   prompt += "最大回撤: " + DoubleToString(Stats.MaxDrawdown, 2) + " USD\n\n";
   
   prompt += "请分析交易表现，指出潜在问题，并提出改进建议。\n";
   
   // 调用DeepSeek API
   string response = CallDeepSeekAPI(prompt);
   
   // 解析响应
   DeepSeekResponse apiResponse = ParseDeepSeekResponse(response);
   
   if(!apiResponse.success) {
      return "AI分析失败: " + apiResponse.error_message;
   }
   
   return apiResponse.content;
}

//+------------------------------------------------------------------+
//| 调用DeepSeek API函数                                            |
//+------------------------------------------------------------------+
string CallDeepSeekAPI(string prompt)
{
   if(!EnableAIAnalysis || StringLen(DeepSeekAPIKey) < 10) {
      return "AI分析未启用";
   }
   
   // 构建请求数据
   string headers = "Content-Type: application/json\r\n";
   headers += "Authorization: Bearer " + DeepSeekAPIKey + "\r\n";
   
   string request_data = "{\n";
   request_data += "  \"model\": \"deepseek-chat\",\n";
   request_data += "  \"messages\": [\n";
   request_data += "    {\n";
   request_data += "      \"role\": \"user\",\n";
   request_data += "      \"content\": \"" + EscapeJSONString(prompt) + "\"\n";
   request_data += "    }\n";
   request_data += "  ],\n";
   request_data += "  \"temperature\": " + DoubleToString(AICreativityParam, 1) + ",\n";
   request_data += "  \"max_tokens\": " + IntegerToString(AIMaxTokens) + ",\n";
   request_data += "  \"stream\": false\n";
   request_data += "}";
   
   if(EnableAPILog) {
      Print("=== DeepSeek API请求 ===");
      Print("URL: ", DeepSeekBaseURL);
      Print("请求数据: ", request_data);
   }
   
   // 发送HTTP请求
   uchar result[];
   string result_headers;
   int response_code;
   
   int res = WebRequest("POST", DeepSeekBaseURL, headers, APITimeout, request_data, result, result_headers, response_code);
   
   if(res == -1) {
      string error_message = "WebRequest错误: " + IntegerToString(GetLastError());
      if(EnableDetailedLog) Print(error_message);
      return "API请求失败: " + error_message;
   }
   
   if(response_code != 200) {
      string error_msg = "HTTP错误代码: " + IntegerToString(response_code);
      if(EnableDetailedLog) Print(error_msg);
      return "API响应错误: " + error_msg;
   }
   
   string response_text = CharArrayToString(result);
   
   if(EnableAPILog) {
      Print("API响应: ", response_text);
   }
   
   return response_text;
}

//+------------------------------------------------------------------+
//| 解析DeepSeek响应函数                                             |
//+------------------------------------------------------------------+
DeepSeekResponse ParseDeepSeekResponse(string json_response)
{
   DeepSeekResponse response;
   response.success = false;
   response.error_message = "未知错误";
   
   if(StringLen(json_response) == 0) {
      response.error_message = "响应为空";
      return response;
   }
   
   // 检查是否是错误响应
   if(StringFind(json_response, "\"error\"") >= 0) {
      int start_pos = StringFind(json_response, "\"message\":\"");
      if(start_pos >= 0) {
         start_pos += 10;
         int end_pos = StringFind(json_response, "\"", start_pos);
         if(end_pos > start_pos) {
            response.error_message = StringSubstr(json_response, start_pos, end_pos - start_pos);
         }
      }
      return response;
   }
   
   // 解析正常响应
   try {
      // 提取content
      int content_start = StringFind(json_response, "\"content\":\"");
      if(content_start >= 0) {
         content_start += 11;
         int content_end = StringFind(json_response, "\"", content_start);
         if(content_end > content_start) {
            response.content = StringSubstr(json_response, content_start, content_end - content_start);
            response.content = UnescapeJSONString(response.content);
         }
      }
      
      response.success = true;
      response.error_message = "";
      
   } catch(Exception e) {
      response.success = false;
      response.error_message = "解析响应时出现异常";
   }
   
   return response;
}

//+------------------------------------------------------------------+
//| 反转义JSON字符串函数                                             |
//+------------------------------------------------------------------+
string UnescapeJSONString(string input)
{
   string output = input;
   StringReplace(output, "\\n", "\n");
   StringReplace(output, "\\r", "\r");
   StringReplace(output, "\\t", "\t");
   StringReplace(output, "\\\"", "\"");
   StringReplace(output, "\\\\", "\\");
   StringReplace(output, "\\/", "/");
   StringReplace(output, "\\b", "\b");
   StringReplace(output, "\\f", "\f");
   return output;
}

//+------------------------------------------------------------------+
//| 生成最终报告函数                                                 |
//+------------------------------------------------------------------+
void GenerateFinalReport(int reason)
{
   string filename = "Final_Report_" + TimeToString(TimeCurrent(), TIME_DATE) + ".txt";
   int handle = FileOpen(filename, FILE_WRITE|FILE_TXT|FILE_COMMON);
   
   if(handle == INVALID_HANDLE) return;
   
   FileWrite(handle, "=== 宇川AI交易系统最终报告 ===");
   FileWrite(handle, "生成时间: " + TimeToString(TimeCurrent()));
   FileWrite(handle, "停止原因: " + GetDeinitReasonDescription(reason));
   FileWrite(handle, "运行时长: " + DoubleToString((TimeCurrent() - StartTime) / 3600.0, 1) + " 小时");
   FileWrite(handle, "总交易次数: " + IntegerToString(TradeRecordCount));
   FileWrite(handle, "当日交易次数: " + IntegerToString(DailyTradeCount));
   FileWrite(handle, "账户余额: " + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2));
   FileWrite(handle, "账户净值: " + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2));
   FileWrite(handle, "=====================================");
   
   FileClose(handle);
   Print("最终报告已生成: ", filename);
}

//+------------------------------------------------------------------+
//| 获取逆初始化原因描述                                             |
//+------------------------------------------------------------------+
string GetDeinitReasonDescription(int reason)
{
   switch(reason)
   {
      case 0:   return "EA被移除";
      case 1:   return "图表被关闭";
      case 2:   return "代码被重新编译";
      case 3:   return "图表时间框架改变";
      case 4:   return "图表品种改变";
      case 5:   return "输入参数改变";
      case 6:   return "账户改变";
      case 7:   return "模板改变";
      case 8:   return "初始化失败";
      case 9:   return "终端关闭";
      default:  return "未知原因 (" + IntegerToString(reason) + ")";
   }
}

//+------------------------------------------------------------------+
//| 市场状态分析函数                                                 |
//+------------------------------------------------------------------+
ENUM_MARKET_STATE AnalyzeMarketState(string symbol, int symbolIndex)
{
   // 获取多时间框架数据
   double atrValue = GetIndicatorValue(atrHandle[symbolIndex]);
   double rsiValue = GetIndicatorValue(rsiHandle_TF1[symbolIndex]);
   double adxValue = GetIndicatorValue(adxHandle[symbolIndex]);

   // 获取价格波动范围
   double high[20], low[20];
   CopyHigh(symbol, PERIOD_H1, 0, 20, high);
   CopyLow(symbol, PERIOD_H1, 0, 20, low);

   double rangeSize = 0;
   for(int i=0; i<20; i++) {
      rangeSize += (high[i] - low[i]);
   }
   rangeSize /= 20;

   // 基于技术指标判断市场状态
   ENUM_MARKET_STATE detectedState = MARKET_RANGE;
   
   if(adxValue > TrendADXThreshold) {
      detectedState = MARKET_TREND;
   } else if(adxValue < RangeADXThreshold) {
      detectedState = MARKET_RANGE;
   } else {
      // 计算波动率比率
      double currentVolatility = (high[0] - low[0]) / SymbolInfoDouble(symbol, SYMBOL_BID);
      double avgVolatility = rangeSize / SymbolInfoDouble(symbol, SYMBOL_BID);
      double volatilityRatio = currentVolatility / avgVolatility;
      
      if(volatilityRatio > BreakoutVolatilityThreshold) {
         detectedState = MARKET_BREAKOUT;
      }
   }

   if(EnableDetailedLog) {
      Print("=== 市场状态分析 ===");
      Print("品种: ", symbol);
      Print("ATR: ", atrValue);
      Print("RSI: ", rsiValue);
      Print("ADX: ", adxValue);
      Print("平均波动范围: ", rangeSize);
      Print("分析结果: ", detectedState);
      Print("===================");
   }

   return detectedState;
}

//+------------------------------------------------------------------+
//| 调整策略配置函数                                                 |
//+------------------------------------------------------------------+
void AdjustStrategyConfig(ENUM_MARKET_STATE state)
{
   switch(state) {
      case MARKET_TREND:
         // 趋势市配置
         TrendFollowingEnabled = true;
         TurtleTradingEnabled = true;
         GoldenCrossEnabled = true;
         MartingaleEnabled = false;     // 趋势市禁用马丁
         GridEnabled = true;       // 只在趋势方向开网格
         MeanReversionEnabled = false;      // 禁用反转策略
         BollingerReversionEnabled = false;
         Print("切换到趋势市策略组合");
         break;

      case MARKET_RANGE:
         // 震荡市配置
         TrendFollowingEnabled = false;
         TurtleTradingEnabled = false;
         GoldenCrossEnabled = false;
         MartingaleEnabled = true;       // 震荡市启用马丁
         GridEnabled = false;      // 震荡市禁用网格
         MeanReversionEnabled = true;       // 启用反转策略
         BollingerReversionEnabled = true;
         Print("切换到震荡市策略组合");
         break;

      case MARKET_BREAKOUT:
         // 突破市配置
         TrendFollowingEnabled = true;
         TurtleTradingEnabled = true;
         VolatilityBreakoutEnabled = true;
         MartingaleEnabled = false;     // 突破市禁用马丁
         GridEnabled = false;    // 突破市禁用网格
         MeanReversionEnabled = false;    // 禁用反转策略
         BollingerReversionEnabled = false;
         Print("切换到突破市策略组合");
         break;
   }
}

//+------------------------------------------------------------------+
//| 获取策略权重函数                                                 |
//+------------------------------------------------------------------+
double GetStrategyWeight(string StrategyName)
{
   if(StrategyName == "TrendFollowing") return TrendFollowingWeight;
   if(StrategyName == "MeanReversion") return MeanReversionWeight;
   if(StrategyName == "TurtleTrading") return TurtleTradingWeight;
   if(StrategyName == "Rule123") return Rule123Weight;
   if(StrategyName == "PriceAction") return PriceActionWeight;
   if(StrategyName == "VolatilityBreakout") return VolatilityBreakoutWeight;
   if(StrategyName == "BollingerBands") return BollingerReversionWeight;
   if(StrategyName == "SMC") return SMCWeight;
   if(StrategyName == "GoldenCross") return GoldenCrossWeight;
   if(StrategyName == "MachineLearning") return MLWeight;
   return 0.1;
}

//+------------------------------------------------------------------+
//| 主程序结束                                                       |
//+------------------------------------------------------------------+
